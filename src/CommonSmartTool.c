//CommonSmartTool.c
//Original Generated by MakeOID20130807.1
//HEAVILY MODIFIED TO INCLUDE Extended Common Smart Tool Code
//Not to be replaced.  Requires Hand Merge
#include "SmartTool.h"
#include "SmartToolUtil.h"
#include "CommonSmartTool.h"
#include "STP.h"

//MakeOID-Section:: OID NAMES ARRAY

char * pszOIDNamesCommon[] =
{
		"NULLOID",
		"DEBUG",
		"SMARTTOOL_TYPE",
		"SMARTTOOL_SUBTYPE",
		"SYSTEM_VERSION",
		"SERIAL_NUMBER",
		"RESET_SYSTEM",
		"SCRIPT_TRANSFER",
		"GENERICMESSAGE",
		"DEBUGMESSAGE",
		"STPSTATUS",
		"COMMON_MESSAGE_CODE",
		"CONTROL_DELAY",
		"DIRECT_DOUT",
		"DIRECT_DIN",
		"COM_VERSION",
		"STREAM_SYNC",
		"STP_CLOSE",
		"STP_IDENTIFY",
		"DATE_TIME",
		"OID_MAX_NUMBER_Common"
};

//MakeOID-Section::END

//MakeOID-Section:: Global Smart Tool ID And Version Constant Defines 

//Common doesn't have it's own COM version or version at this time

//MakeOID-Section:: CONFIG DECLARATION

//Common has no config oids

//MakeOID-Section::END

//MakeOID-Section:: GLOBAL DECLARATIONS

char g_szSerialNumber[64] = "\0";
td_StpStatus g_StpStatus = { 0, STPSTAT_OK };
td_DateTime g_DateTime = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
//MakeOID-Section::END

//MakeOID-generated:: CONFIG DEFAULTS (oid complete)

//Common has no config oids

//MakeOID-generated::END

//OID Handling Functions

//Maintain g_DateTime
//Internal Variable:
uint32 g_ulDateTimeMS = 0;

void ServiceDateTime()
{
	unsigned long ulNewDateTimeMS;
	unsigned long ul;
//unsigned long ulM;
	unsigned long ulL;
	unsigned long ulMSW;
	unsigned long ulLSW;
//unsigned long ulSec;
	unsigned int ui;
	unsigned long t1;
	unsigned long t2;
	char mdays;

	ulNewDateTimeMS = MS_TIMER;
	ul = ulNewDateTimeMS - g_ulDateTimeMS;
	g_ulDateTimeMS = ulNewDateTimeMS;

//g_DateTime.ulticksMSW = 0;
//g_DateTime.ulticksLSW = 0;

//logf("ul=%lu\r\n",ul);
//logf("dt %lu %lu\r\n", g_DateTime.ulticksMSW, g_DateTime.ulticksLSW);
	if (ul <= 429496)
	{
		//ul is small enough that this won't carry
		ulLSW = ul * 10000;
	}
	else
	{
		//the multiplication is going to be LARGER than the 32 bit number available.
		//Do it in parts
		t1 = (ul & 0xffff) * 10000;
		t2 = ((ul >> 16) * 10000) + (t1 >> 16);
		ulLSW = ((t2 & 0xffff) << 16) | (t1 & 0xffff);
		ulMSW = (t2 >> 16);
//logf("add %lu %lu\r\n",ulMSW, ulLSW);
		g_DateTime.ulticksMSW += ulMSW;
	}

//Now Add LSW to g_DateTime, and Increment MSW if needed
	ulL = g_DateTime.ulticksLSW; //save original LSW
	ulLSW += ulL;				//find new LSW
	g_DateTime.ulticksLSW = ulLSW;
	if (ulLSW < ulL)
	{
		//it wrapped
		g_DateTime.ulticksMSW++;
	}
//logf("dt %lu %lu\r\n", g_DateTime.ulticksMSW, g_DateTime.ulticksLSW);

	if (g_DateTime.uiyear > 0)
	{
		ul += g_DateTime.uimillisecond;
		if (ul < 1000)
		{
			g_DateTime.uimillisecond = (unsigned int) ul;
			goto done_roll;
		}
		g_DateTime.uimillisecond = (unsigned int) (ul % 1000);
		ul = ul / 1000;
		ul += g_DateTime.csecond;
		if (ul < 60)
		{
			g_DateTime.csecond = (char) ul;
			goto done_roll;
		}
		g_DateTime.csecond = (char) (ul % 60);
		ul = ul / 60;
		ul += g_DateTime.cminute;
		if (ul < 60)
		{
			g_DateTime.cminute = (char) ul;
			goto done_roll;
		}
		g_DateTime.cminute = (char) (ul % 60);
		ul = ul / 60;
		ul += g_DateTime.chour;
		if (ul < 24)
		{
			g_DateTime.chour = (char) ul;
			goto done_roll;
		}
		g_DateTime.chour = (char) (ul % 24);
		ul = ul / 24;
		ul += g_DateTime.cdayOfMonth;
		//	unsigned int uiyear;
		//	char cmonth;

		while (1)
		{
			//If days is less than 28, then no point in finding true max days of this month
			if (ul <= 28)
			{
				g_DateTime.cdayOfMonth = (char) ul;
				goto done_roll;
			}
			//Find max days of this month
			mdays = 31;
			if (g_DateTime.cmonth == 2)
			{
				mdays = 28;
				ui = g_DateTime.uiyear;
				if (ui % 400 == 0)
				{
					//leap
					mdays = 29;
				}
				else if (ui % 100 == 0)
				{
					//not leap
				}
				else if (ui % 4 == 0)
				{
					//leap
					mdays = 29;
				}
				else
				{
					//not leap
				}
			}
			else if (g_DateTime.cmonth == 4 || g_DateTime.cmonth == 6
					|| g_DateTime.cmonth == 9 || g_DateTime.cmonth == 11)
			{
				mdays = 30;
			}
			//If less than or equal to max days, then this is the date
			if (ul <= mdays)
			{
				g_DateTime.cdayOfMonth = (char) ul;
				goto done_roll;
			}
			//add this month, and take away the number of days
			ul -= mdays;
			g_DateTime.cmonth++;
			if (g_DateTime.cmonth == 13)
			{
				//advance the year and reset the month
				g_DateTime.uiyear++;
				g_DateTime.cmonth = 1;
			}
		}
	}
	done_roll:
	return;
}

void HandleCommonOIDDateTimeGet(td_STPsessions * p_STPSession)
{
	ServiceDateTime(); //update g_DateTime based on MS_TIMER
	td_DateTime * p_DateTime = (td_DateTime *) g_STPtxMsg.p_cObjectValue;
	p_DateTime->ulticksMSW = htonl(g_DateTime.ulticksMSW);
	p_DateTime->ulticksLSW = htonl(g_DateTime.ulticksLSW);
	p_DateTime->uiyear = htons(g_DateTime.uiyear);
	p_DateTime->cmonth = g_DateTime.cmonth;
	p_DateTime->cdayOfMonth = g_DateTime.cdayOfMonth;
	p_DateTime->chour = g_DateTime.chour;
	p_DateTime->cminute = g_DateTime.cminute;
	p_DateTime->csecond = g_DateTime.csecond;
	p_DateTime->uimillisecond = htons(g_DateTime.uimillisecond);
	SmartToolMsg(p_STPSession, STP_GET_RESP, COMMON_OID_DATE_TIME, sizeof(td_DateTime), g_STPtxMsg.p_cObjectValue);
}

void HandleCommonOIDDateTimeSet(td_DateTime * p_DateTime)
{
	g_DateTime.ulticksMSW = ntohl(p_DateTime->ulticksMSW);
	g_DateTime.ulticksLSW = ntohl(p_DateTime->ulticksLSW);
	g_DateTime.uiyear = ntohs(p_DateTime->uiyear);
	g_DateTime.cmonth = p_DateTime->cmonth;
	g_DateTime.cdayOfMonth = p_DateTime->cdayOfMonth;
	g_DateTime.chour = p_DateTime->chour;
	g_DateTime.cminute = p_DateTime->cminute;
	g_DateTime.csecond = p_DateTime->csecond;
	g_DateTime.uimillisecond = ntohs(p_DateTime->uimillisecond);
	g_ulDateTimeMS = MS_TIMER;
}

